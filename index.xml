<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>展白的博客</title><link>http://blog.zhanxiaobai.com/</link><description>Recent content on 展白的博客</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Thu, 04 Aug 2022 08:55:51 +0800</lastBuildDate><atom:link href="http://blog.zhanxiaobai.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Go 实例：去除字符串首尾的空格</title><link>http://blog.zhanxiaobai.com/posts/12_go_cookbook_010/</link><pubDate>Thu, 04 Aug 2022 08:55:51 +0800</pubDate><guid>http://blog.zhanxiaobai.com/posts/12_go_cookbook_010/</guid><description>问题 希望从字符串开头和末尾删除空白符。例如，在验证用户输入之前，可能希望先完成清理。
解决方案 可以使用 strings.TrimLeft、strings.TrimRight 或 strings.Trim。strings.TrimLeft 方法从字符串开头删除空白符，strings.TrimRight 从字符串末尾删除空白符，strings.Trim 则会删除字符串开头和末尾的空白符，如下所示：
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;strings&amp;#34; ) func main() { fmt.Println(strings.Trim(&amp;#34; zipcode &amp;#34;, &amp;#34; \t\n\r\000\x0B&amp;#34;)) fmt.Println(strings.TrimRight(&amp;#34;text &amp;#34;, &amp;#34; \t\n\r\000\x0B&amp;#34;)) fmt.Println(strings.TrimLeft(&amp;#34; name&amp;#34;, &amp;#34; \t\n\r\000\x0B&amp;#34;)) } 输出如下：
zipcode text name 讨论 对于这些使用方法，空白符定义为以下字符：普通空格符、制表符、换行符、回车符、空字节符以及垂直制表符。
从字符串去除首尾的空白符不仅可以节省存储空间，还有利于更准确的显示格式化数据或文本，如 标记中的文本。如果要对用户输入完成比较，首先需要去除数据首尾的空白符。如果有人在 310000 后面错误的输入了一些空格，并把它作为邮政编码，通过去除字符串首尾的空白符，就不会要求修正这个本不算错误的 “错误”。完成本文比较之前先去除首尾空白符还可以确保完成正确的比较，例如 “salami\n” 等于 “salami”。将字符串数据存储到数据库之前，还可以通过去除首尾的空白符来规范化数据，这也是一个很好的想法。
strings.Trim 方法还可以从字符串删除用户指定的其它字符。可以将想要删除的字符作为第二个参数传入这个方法。
参见 strings.TrimLeft 的有关文档（https://golang.google.cn/pkg/strings/#TrimLeft）。
strings.TrimRight 的有关文档（https://golang.google.cn/pkg/strings/#TrimRight）。
strings.Trim 的有关文档（https://golang.google.cn/pkg/strings/#Trim）。</description></item><item><title>Go 实例：字符串中的内插函数和表达式</title><link>http://blog.zhanxiaobai.com/posts/11_go_cookbook_009/</link><pubDate>Wed, 03 Aug 2022 08:55:51 +0800</pubDate><guid>http://blog.zhanxiaobai.com/posts/11_go_cookbook_009/</guid><description>问题 希望在一个字符串中包含执行某个函数或表达式的结果。
解决方案 如果想要包含的值无法直接放在字符串中，就可以使用字符串连接操作符（+），如下所示：
package main import &amp;#34;fmt&amp;#34; func getDiameter() string { return &amp;#34;20&amp;#34; } func main() { bn := 2 gn := 2 fmt.Println(&amp;#34;You have &amp;#34; + fmt.Sprint(bn+gn) + &amp;#34; children.&amp;#34;) w := &amp;#34;hello&amp;#34; fmt.Println(&amp;#34;The word &amp;#34; + w + &amp;#34; is &amp;#34; + fmt.Sprint(len([]rune(w))) + &amp;#34; characters long.&amp;#34;) p := &amp;#34;20.5&amp;#34; fmt.Println(&amp;#34;You owe &amp;#34; + p + &amp;#34; immediately.&amp;#34;) fmt.Println(&amp;#34;My circle&amp;#39;s diameter is &amp;#34; + getDiameter() + &amp;#34; inches.</description></item><item><title>Go 实例：控制大小写</title><link>http://blog.zhanxiaobai.com/posts/10_go_cookbook_008/</link><pubDate>Tue, 02 Aug 2022 08:55:51 +0800</pubDate><guid>http://blog.zhanxiaobai.com/posts/10_go_cookbook_008/</guid><description>问题 需要将字符串中的字母改为全大写或全小写，或者改变字母的大小写。例如，希望名字中首字母大写，而其余字母都为小写。
解决方案 使用自定义函数 ucfirst 或 strings.Title 将一个或多个单词中的首字母大写，如下所示：
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;strings&amp;#34; &amp;#34;unicode&amp;#34; ) // 将字符串的首字母转换为大写 func ucfirst(s string) string { for _, v := range s { u := string(unicode.ToUpper(v)) return u + s[len(u):] } return &amp;#34;&amp;#34; } func main() { s := &amp;#34;how do you do today?&amp;#34; fmt.Println(ucfirst(s)) s = &amp;#34;the prince of wales&amp;#34; fmt.Println(strings.Title(s)) } 输出如下：
How do you do today? The Prince Of Wales 使用 strings.</description></item><item><title>Go 实例：扩展和压缩制表符</title><link>http://blog.zhanxiaobai.com/posts/09_go_cookbook_007/</link><pubDate>Mon, 01 Aug 2022 08:05:50 +0800</pubDate><guid>http://blog.zhanxiaobai.com/posts/09_go_cookbook_007/</guid><description>问题 希望将字符串中的空格改为制表符（或者将制表符改为空格），但仍保证文本按制表位对齐。例如，可能想以一种标准化的方式为用户显示格式化文本。
解决方案 使用 strings.Replace 将空格替换为制表符，或者将制表符替换为空格，如下所示：
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;strings&amp;#34; ) func main() { msg := &amp;#34;白日依山尽 黄河入海流 欲穷千里目 更上一层楼&amp;#34; tabbed := strings.Replace(msg, &amp;#34; &amp;#34;, &amp;#34;\t&amp;#34;, -1) spaced := strings.Replace(msg, &amp;#34;\t&amp;#34;, &amp;#34; &amp;#34;, -1) fmt.Println(&amp;#34;With Tabs: &amp;#34; + tabbed) fmt.Println(&amp;#34;With Spaces: &amp;#34; + spaced) } 输出如下：
With Tabs: 白日依山尽 黄河入海流 欲穷千里目 更上一层楼 With Spaces: 白日依山尽 黄河入海流 欲穷千里目 更上一层楼 不过，如果使用 strings.Replace 来完成替换，并不能保证按制表位对齐。如果希望每 8 个字符一个制表位，假设一行文本开头有一个 5 字母的单词和一个制表符，这个制表符就应当替换为 3 个空格，而不是一个空格。可以使用如下示例的 tabExpand 函数将制表符替换为空格，同时保证按制表位对齐。</description></item><item><title>Go 实例：生成随机字符串</title><link>http://blog.zhanxiaobai.com/posts/08_go_cookbook_006/</link><pubDate>Fri, 29 Jul 2022 06:05:51 +0800</pubDate><guid>http://blog.zhanxiaobai.com/posts/08_go_cookbook_006/</guid><description>问题 希望生成一个随机字符串。
解决方案 自定义 strRand 函数，如下所示：
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math/rand&amp;#34; &amp;#34;time&amp;#34; ) // 生成随机字符串 func strRand(l int, chars string) string { if chars == &amp;#34;&amp;#34; { chars = &amp;#34;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&amp;#34; } str := &amp;#34;&amp;#34; r := rand.New(rand.NewSource(time.Now().UnixNano())) for i := l; i &amp;gt; 0; i-- { str += string(chars[r.Intn(len(chars))]) } return str } func main() { fmt.Println(strRand(32, &amp;#34;&amp;#34;)) } 讨论 Go 提供了生成随机数的内置方法，不过没有生成随机字符串的方法。strRand 函数返回一个由字母和数字构成的字符串。
传入一个整数可以改变返回字符串的长度。如果要使用另一个字符集合，可以相应地传入一个字符串作为第二个参数。例如，可以如下得到一个 16 位摩斯电码：
fmt.Println(strRand(16, &amp;#34;.-&amp;#34;)) 输出如下：</description></item><item><title>Go 实例：按单词或字节反转字符串</title><link>http://blog.zhanxiaobai.com/posts/07_go_cookbook_005/</link><pubDate>Thu, 28 Jul 2022 09:27:51 +0800</pubDate><guid>http://blog.zhanxiaobai.com/posts/07_go_cookbook_005/</guid><description>问题 希望反转一个字符串中的单词或字节。
解决方案 自定义 strrev 函数按字节反转，如下所示：
package main import ( &amp;#34;fmt&amp;#34; ) // 按字节反转字符串 func strrev(s string) string { n := len(s) runes := make([]rune, n) for _, rune := range s { n-- runes[n] = rune } return string(runes[n:]) } func main() { fmt.Println(strrev(&amp;#34;This is not a palindrome.&amp;#34;)) } 输出如下：
.emordnilap a ton si sihT 要按单词反转，需要根据单词边界分解字符串，反转这些单词，然后再重新组合，如下所示：
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;strings&amp;#34; ) // 反转单词数组 func arrayReverse(s []string) []string { for i, j := 0, len(s)-1; i &amp;lt; j; i, j = i+1, j-1 { s[i], s[j] = s[j], s[i] } return s } func main() { s := &amp;#34;Once upon a time there was a turtle.</description></item><item><title>Go 实例：逐字节处理字符串</title><link>http://blog.zhanxiaobai.com/posts/06_go_cookbook_004/</link><pubDate>Thu, 28 Jul 2022 06:27:51 +0800</pubDate><guid>http://blog.zhanxiaobai.com/posts/06_go_cookbook_004/</guid><description>问题 需要分别处理字符串中的各个字节。
解决方案 使用 for 循环处理字符串中的各个字节，如下所示可以统计一个字符串中的元音字母个数。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;strings&amp;#34; ) func main() { s := &amp;#34;This weekend, I&amp;#39;m going shopping for a pet chicken.&amp;#34; vowels := 0 for _, v := range s { if strings.Index(&amp;#34;aeiouAEIOU&amp;#34;, string(v)) != -1 { vowels++ } } fmt.Println(vowels) } 输出如下：
14 讨论 通过一次处理字符串中的一个字符，可以很容易的计算 “Look and Say” 序列（J.H.Conway 提出的一个整数序列），如下所示：
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;strconv&amp;#34; ) func lookandsay(s string) string { // 将返回值初始化为一个空串 r := &amp;#34;&amp;#34; // m 包含要统计的字符，初始化为字符串中的第一个字符 m := s[0] // n 是已经查看过的 m 个数，初始化为 1 n := 1 for i := 1; i &amp;lt; len([]rune(s)); i++ { // 如果这个字符与上一个相同 if s[i] == m { // 将这个字符的个数增加 1 n++ } else { // 否则，将字符个数和字符本身增加到返回值 r += strconv.</description></item><item><title>Go 实例：替换子串</title><link>http://blog.zhanxiaobai.com/posts/05_go_cookbook_003/</link><pubDate>Wed, 27 Jul 2022 21:27:51 +0800</pubDate><guid>http://blog.zhanxiaobai.com/posts/05_go_cookbook_003/</guid><description>问题 希望用另外一个不同的字符串来替换一个子串。例如，打印一个信用卡号之前，想要对除了后四位以外的部分模糊处理。
解决方案 使用 strings.Replace，如下所示。
// 将字符串 s 中的前 n 个 old 字符串替换为 new 字符串，如果 n 为 -1 则全部替换 newString := strings.Replace(s, old, new, n) 讨论 下面封装了一个 replace 函数，方便替换从 start 到指定 length 长度的字符，其中 start 和 length 不可为负数。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;strings&amp;#34; ) func replace(s string, new string, start int, length int) string { return strings.Replace(s, string([]rune(s)[start:start+length]), new, 1) } func main() { s := &amp;#34;My pet is a blue dog.</description></item><item><title>Go 实例：抽取子串</title><link>http://blog.zhanxiaobai.com/posts/04_go_cookbook_002/</link><pubDate>Wed, 27 Jul 2022 09:22:13 +0800</pubDate><guid>http://blog.zhanxiaobai.com/posts/04_go_cookbook_002/</guid><description>问题 希望从字符串中的某个特定位置开始抽取这个字符串的一部分。例如，对于输入到一个表单的用户名，想要得到这个用户名的前 8 个字符。
解决方案 使用 string 和 rune 选择子串，如下所示：
package main import &amp;#34;fmt&amp;#34; func main() { // 用法：string([]rune(str)[start:start+length]) username := &amp;#34;zhanbai展白&amp;#34; username = string([]rune(username)[:8]) fmt.Println(username) } 讨论 string 和 rune 结合可以完全不用考虑 unicode 字节问题，一个中文就只占一个数组下标。start 和 length 必须是正整数并且不能超过字符串长度，start 可以忽略，即从 0 开始，以上会返回从 start 开始的 length 个字符。字符中的第一个位置为 0。如果忽略 start+length，会返回从 start 到原字符串末尾的子串，如下所示：
package main import &amp;#34;fmt&amp;#34; func main() { s := &amp;#34;watch out for that tree&amp;#34; s = string([]rune(s)[17:]) fmt.Println(s) } 输出如下：
t tree 参见 string 的有关文档（https://golang.</description></item><item><title>Go 实例：访问子串</title><link>http://blog.zhanxiaobai.com/posts/03_go_cookbook_001/</link><pubDate>Wed, 27 Jul 2022 07:05:51 +0800</pubDate><guid>http://blog.zhanxiaobai.com/posts/03_go_cookbook_001/</guid><description>问题 想知道一个字符串是否包含一个特定的子串。例如，想查看一个 email 地址是否包含一个 @。
解决方案 使用 strings.Index 如下所示：
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;strings&amp;#34; ) func main() { email := &amp;#34;bai.zhan@qq.com&amp;#34; if strings.Index(email, &amp;#34;@&amp;#34;) != -1 { fmt.Println(&amp;#34;There was @ in the e-mail address!&amp;#34;) } } 讨论 strings.Index 的返回值是子串（就像“要捞的针”）在字符串（就像“大海”）中出现的第一个位置。如果大海（字符串）中根本没有找到针（子串），strings.Index 将返回 -1 。如果子串位于这个字符串的起始位置，strings.Index 将返回 0，因为位置 0 表示字符串的开始位置。
参见 strings.Index 的有关文档，https://golang.google.cn/pkg/strings/#Index 。</description></item><item><title>搭建 Go 开发环境</title><link>http://blog.zhanxiaobai.com/posts/02_go_install/</link><pubDate>Thu, 02 Dec 2021 11:06:51 +0800</pubDate><guid>http://blog.zhanxiaobai.com/posts/02_go_install/</guid><description>本文介绍 Go 开发环境的搭建。
本教程基于 MacOS 系统
关于 Go Go 是一门具有表现力、简洁、干净和高效的，支持高并发的开源静态编译型语言。
安装 首先，下载 Go for Mac 软件包，然后打开按照提示进行安装。Go 发行版将会被安装到 /usr/local/go 目录，/usr/local/go/bin 也将被加入 PATH 环境变量，然后重启终端将会生效。
验证是否安装成功：
$ go version 编写程序 推荐使用 VSCode 编写程序，并安装 Go 扩展。
进入家目录，并创建 hello 项目文件夹：
$ cd $ mkdir hello $ cd hello 启用依赖项跟踪：
$ go mod init example/hello go: creating new go.mod: module example/hello 通过编辑器创建 hello.go 文件，并编写以下代码：
package main import &amp;#34;fmt&amp;#34; func main() { fmt.Println(&amp;#34;Hello, World!&amp;#34;) } 运行这个程序：
$ go run .</description></item><item><title>使用 Hugo 和 GitHub Pages 构建免费博客网站</title><link>http://blog.zhanxiaobai.com/posts/01_hugo_install/</link><pubDate>Wed, 01 Dec 2021 14:22:44 +0800</pubDate><guid>http://blog.zhanxiaobai.com/posts/01_hugo_install/</guid><description>本文介绍如何使用 Hugo 和 Github Pages 来构建、维护和管理免费的博客网站。
基于 MacOS 系统，另外前提需要安装 Git 工具。
关于 Hugo Hugo 是基于 Go 语言开发的开源静态站点生成器，具有快速、灵活的特点。
安装 Hugo $ brew install hugo 验证是否安装成功：
$ hugo version 创建一个新的网站 $ hugo new site myblog 配置主题 本文使用了简单、轻量的 Coder 主题。
$ cd myblog $ git init $ git submodule add https://github.com/luizdepra/hugo-coder.git themes/hugo-coder 编辑根目录下配置文件 config.toml，具体参数可以参考 themes/hugo-coder/exampleSite/config.toml 例子中的配置。
以下是我使用的比较精简的配置参数：
baseURL = &amp;#34;http://blog.zhanxiaobai.com/&amp;#34; defaultContentLanguage = &amp;#34;zh-cn&amp;#34; title = &amp;#34;展白的博客&amp;#34; theme = &amp;#34;hugo-coder&amp;#34; [[languages.zh-cn.menu.main]] name = &amp;#34;文章&amp;#34; weight = 1 url = &amp;#34;posts/&amp;#34; [[languages.</description></item><item><title>关于</title><link>http://blog.zhanxiaobai.com/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://blog.zhanxiaobai.com/about/</guid><description>展白，生于 1991 年。
Web 开发从业者，同时也是自由软件的倡导者和拥护者。
现就职于杭州一家互联网创业公司，从事项目研发和管理工作。
业余时间，喜欢看书，写作，上网，健身。
阅读列表 2022.01.05《呐喊》
2022.01.10《工作、消费主义和新穷人》
2022.01.20《骆驼祥子》
2022.01.28《边城》
2022.06.02《人世间》
2022.07.03《围城》
2022.07.10《教父》
2022.07.30《一句顶一万句》
2022.08.02《活着》</description></item></channel></rss>